; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt < %s  -S -passes='extend-cycle-convergence' 2>&1 | FileCheck %s

;
;     |
;     A]       %a1 = anchor
;     |
;     B
;     |\
;     | C
;     |/ \
;     D  |
;        E     %e = user (%a1)
;

define void @extend_loops(i1 %flag1, i1 %flag2, i1 %flag3) {
; CHECK-LABEL: define void @extend_loops(
; CHECK-SAME: i1 [[FLAG1:%.*]], i1 [[FLAG2:%.*]], i1 [[FLAG3:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    br label %[[A1:.*]]
; CHECK:       [[A1]]:
; CHECK-NEXT:    [[A:%.*]] = call token @llvm.experimental.convergence.anchor()
; CHECK-NEXT:    br i1 [[FLAG1]], label %[[EXTEND_GUARD:.*]], label %[[B:.*]]
; CHECK:       [[B]]:
; CHECK-NEXT:    br i1 [[FLAG2]], label %[[C:.*]], label %[[D:.*]]
; CHECK:       [[C]]:
; CHECK-NEXT:    br i1 [[FLAG3]], label %[[D]], label %[[E_EXT:.*]]
; CHECK:       [[D]]:
; CHECK-NEXT:    ret void
; CHECK:       [[E_EXT]]:
; CHECK-NEXT:    call void @convergent.op(i32 0) [ "convergencectrl"(token [[A]]) ]
; CHECK-NEXT:    br label %[[EXTEND_GUARD]]
; CHECK:       [[E:.*]]:
; CHECK-NEXT:    br label %[[F:.*]]
; CHECK:       [[F]]:
; CHECK-NEXT:    ret void
; CHECK:       [[EXTEND_GUARD]]:
; CHECK-NEXT:    [[GUARD_E:%.*]] = phi i1 [ true, %[[E_EXT]] ], [ false, %[[A1]] ]
; CHECK-NEXT:    br i1 [[GUARD_E]], label %[[E]], label %[[A1]]
;
entry:
  br label %A

A:
  %a1 = call token @llvm.experimental.convergence.anchor()
  br i1 %flag1, label %A, label %B

B:
  br i1 %flag2, label %C, label %D

C:
  br i1 %flag3, label %D, label %E

D:
  ret void

E:
  call void @convergent.op(i32 0) [ "convergencectrl"(token %a1) ]
  br label %F

F:
  ret void
}

;
;     |
;     A]       %a1 = anchor
;     |
;     B        %b1 = anchor
;    / \
;   C   \
;  / \  |
; D   | |
;     E |      %e = user (%b1)
;       |
;       F      %f = user (%a1)
;

define void @extend_loops_iterate(i1 %flag1, i1 %flag2, i1 %flag3) {
; CHECK-LABEL: define void @extend_loops_iterate(
; CHECK-SAME: i1 [[FLAG1:%.*]], i1 [[FLAG2:%.*]], i1 [[FLAG3:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    br label %[[A1:.*]]
; CHECK:       [[A1]]:
; CHECK-NEXT:    [[A:%.*]] = call token @llvm.experimental.convergence.anchor()
; CHECK-NEXT:    br i1 [[FLAG1]], label %[[EXTEND_GUARD:.*]], label %[[B1:.*]]
; CHECK:       [[B1]]:
; CHECK-NEXT:    [[B:%.*]] = call token @llvm.experimental.convergence.anchor()
; CHECK-NEXT:    br i1 [[FLAG2]], label %[[C:.*]], label %[[F_EXT:.*]]
; CHECK:       [[C]]:
; CHECK-NEXT:    br i1 [[FLAG3]], label %[[D:.*]], label %[[E_EXT:.*]]
; CHECK:       [[D]]:
; CHECK-NEXT:    ret void
; CHECK:       [[E_EXT]]:
; CHECK-NEXT:    call void @convergent.op(i32 0) [ "convergencectrl"(token [[B]]) ]
; CHECK-NEXT:    br label %[[EXTEND_GUARD]]
; CHECK:       [[E:.*]]:
; CHECK-NEXT:    ret void
; CHECK:       [[F_EXT]]:
; CHECK-NEXT:    call void @convergent.op(i32 0) [ "convergencectrl"(token [[A]]) ]
; CHECK-NEXT:    br label %[[EXTEND_GUARD]]
; CHECK:       [[F:.*]]:
; CHECK-NEXT:    ret void
; CHECK:       [[EXTEND_GUARD]]:
; CHECK-NEXT:    [[GUARD_F:%.*]] = phi i1 [ true, %[[F_EXT]] ], [ false, %[[E_EXT]] ], [ false, %[[A1]] ]
; CHECK-NEXT:    [[GUARD_E:%.*]] = phi i1 [ false, %[[F_EXT]] ], [ true, %[[E_EXT]] ], [ false, %[[A1]] ]
; CHECK-NEXT:    br i1 [[GUARD_F]], label %[[F]], label %[[EXTEND_GUARD1:.*]]
; CHECK:       [[EXTEND_GUARD1]]:
; CHECK-NEXT:    br i1 [[GUARD_E]], label %[[E]], label %[[A1]]
;
entry:
  br label %A

A:
  %a1 = call token @llvm.experimental.convergence.anchor()
  br i1 %flag1, label %A, label %B

B:
  %b1 = call token @llvm.experimental.convergence.anchor()
  br i1 %flag2, label %C, label %F

C:
  br i1 %flag3, label %D, label %E

D:
  ret void

E:
  call void @convergent.op(i32 0) [ "convergencectrl"(token %b1) ]
  ret void

F:
  call void @convergent.op(i32 0) [ "convergencectrl"(token %a1) ]
  ret void
}

;
;     |
;     A<-\     %a1 = heart
;     |  |
;     B] |     %b1 = heart (%a1)
;     |  |
;     C>-/
;     |
;     D        %d1 = user (%b1)
;              %d2 = user (%a1)
;

define void @nested_loop_extension(i1 %flag1, i1 %flag2) {
; CHECK-LABEL: define void @nested_loop_extension(
; CHECK-SAME: i1 [[FLAG1:%.*]], i1 [[FLAG2:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[ANCHOR:%.*]] = call token @llvm.experimental.convergence.anchor()
; CHECK-NEXT:    br label %[[A1:.*]]
; CHECK:       [[A1]]:
; CHECK-NEXT:    [[A:%.*]] = call token @llvm.experimental.convergence.loop() [ "convergencectrl"(token [[ANCHOR]]) ]
; CHECK-NEXT:    br label %[[B1:.*]]
; CHECK:       [[B1]]:
; CHECK-NEXT:    [[B:%.*]] = call token @llvm.experimental.convergence.loop() [ "convergencectrl"(token [[A]]) ]
; CHECK-NEXT:    br i1 [[FLAG1]], label %[[EXTEND_GUARD1:.*]], label %[[C:.*]]
; CHECK:       [[C]]:
; CHECK-NEXT:    br i1 [[FLAG2]], label %[[EXTEND_GUARD:.*]], label %[[D_EXT_EXT:.*]]
; CHECK:       [[D_EXT_EXT]]:
; CHECK-NEXT:    call void @convergent.op(i32 0) [ "convergencectrl"(token [[B]]) ]
; CHECK-NEXT:    br label %[[EXTEND_GUARD1]]
; CHECK:       [[D_EXT:.*]]:
; CHECK-NEXT:    call void @convergent.op(i32 0) [ "convergencectrl"(token [[A]]) ]
; CHECK-NEXT:    br label %[[EXTEND_GUARD]]
; CHECK:       [[D:.*]]:
; CHECK-NEXT:    ret void
; CHECK:       [[EXTEND_GUARD]]:
; CHECK-NEXT:    [[GUARD_D:%.*]] = phi i1 [ true, %[[D_EXT]] ], [ false, %[[C]] ]
; CHECK-NEXT:    br i1 [[GUARD_D]], label %[[D]], label %[[A1]]
; CHECK:       [[EXTEND_GUARD1]]:
; CHECK-NEXT:    [[GUARD_D_EXT:%.*]] = phi i1 [ true, %[[D_EXT_EXT]] ], [ false, %[[B1]] ]
; CHECK-NEXT:    br i1 [[GUARD_D_EXT]], label %[[D_EXT]], label %[[B1]]
;
entry:
  %anchor = call token @llvm.experimental.convergence.anchor()
  br label %A

A:
  %a1 = call token @llvm.experimental.convergence.loop() [ "convergencectrl"(token %anchor) ]
  br label %B

B:
  %b1 = call token @llvm.experimental.convergence.loop() [ "convergencectrl"(token %a1) ]
  br i1 %flag1, label %B, label %C

C:
  br i1 %flag2, label %A,label %D

D:
  call void @convergent.op(i32 0) [ "convergencectrl"(token %b1) ]
  call void @convergent.op(i32 0) [ "convergencectrl"(token %a1) ]
  ret void
}

;
;    |
;    A]      %a1 = anchor
;    |
;    B       %b1 = anchor       <-- should be associated to extended cycle!
;    |\      %b2 = user (%b1)
;    | X
;    C       %c = user (%a1)
;

define void @multi_block_extension(i1 %flag1, i1 %flag2) {
; CHECK-LABEL: define void @multi_block_extension(
; CHECK-SAME: i1 [[FLAG1:%.*]], i1 [[FLAG2:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    br label %[[A1:.*]]
; CHECK:       [[A1]]:
; CHECK-NEXT:    [[A:%.*]] = call token @llvm.experimental.convergence.anchor()
; CHECK-NEXT:    br i1 [[FLAG1]], label %[[EXTEND_GUARD:.*]], label %[[B:.*]]
; CHECK:       [[B]]:
; CHECK-NEXT:    [[B1:%.*]] = call token @llvm.experimental.convergence.anchor()
; CHECK-NEXT:    call void @convergent.op(i32 0) [ "convergencectrl"(token [[B1]]) ]
; CHECK-NEXT:    br i1 [[FLAG2]], label %[[X:.*]], label %[[C_EXT:.*]]
; CHECK:       [[X]]:
; CHECK-NEXT:    ret void
; CHECK:       [[C_EXT]]:
; CHECK-NEXT:    call void @convergent.op(i32 0) [ "convergencectrl"(token [[A]]) ]
; CHECK-NEXT:    br label %[[EXTEND_GUARD]]
; CHECK:       [[C:.*]]:
; CHECK-NEXT:    ret void
; CHECK:       [[EXTEND_GUARD]]:
; CHECK-NEXT:    [[GUARD_C:%.*]] = phi i1 [ true, %[[C_EXT]] ], [ false, %[[A1]] ]
; CHECK-NEXT:    br i1 [[GUARD_C]], label %[[C]], label %[[A1]]
;
entry:
  br label %A

A:
  %a1 = call token @llvm.experimental.convergence.anchor()
  br i1 %flag1, label %A, label %B

B:
  %b1 = call token @llvm.experimental.convergence.anchor()
  call void @convergent.op(i32 0) [ "convergencectrl"(token %b1) ]
  br i1 %flag2, label %X, label %C

X:
  ret void

C:
  call void @convergent.op(i32 0) [ "convergencectrl"(token %a1) ]
  ret void
}

;
;    |
;    A]      %a1 = anchor
;    |
;    B       %b1 = anchor       <-- should be associated to extended cycle!
;            %b2 = user (%b1)
;            %b3 = user (%a1)
;

define void @multi_extension(i1 %flag1) {
; CHECK-LABEL: define void @multi_extension(
; CHECK-SAME: i1 [[FLAG1:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    br label %[[A1:.*]]
; CHECK:       [[A1]]:
; CHECK-NEXT:    [[A:%.*]] = call token @llvm.experimental.convergence.anchor()
; CHECK-NEXT:    br i1 [[FLAG1]], label %[[EXTEND_GUARD:.*]], label %[[B_EXT:.*]]
; CHECK:       [[B_EXT]]:
; CHECK-NEXT:    [[B1:%.*]] = call token @llvm.experimental.convergence.anchor()
; CHECK-NEXT:    call void @convergent.op(i32 0) [ "convergencectrl"(token [[B1]]) ]
; CHECK-NEXT:    call void @convergent.op(i32 0) [ "convergencectrl"(token [[A]]) ]
; CHECK-NEXT:    br label %[[EXTEND_GUARD]]
; CHECK:       [[B:.*]]:
; CHECK-NEXT:    ret void
; CHECK:       [[EXTEND_GUARD]]:
; CHECK-NEXT:    [[GUARD_B:%.*]] = phi i1 [ true, %[[B_EXT]] ], [ false, %[[A1]] ]
; CHECK-NEXT:    br i1 [[GUARD_B]], label %[[B]], label %[[A1]]
;
entry:
  br label %A

A:
  %a1 = call token @llvm.experimental.convergence.anchor()
  br i1 %flag1, label %A, label %B

B:
  %b1 = call token @llvm.experimental.convergence.anchor()
  call void @convergent.op(i32 0) [ "convergencectrl"(token %b1) ]
  call void @convergent.op(i32 0) [ "convergencectrl"(token %a1) ]
  ret void
}

;
;    |
;    A]     %a1 = anchor
;    |
;    B]     %b1 = loop heart (%a1)
;    |      %b2 = user (%b1)
;    |
;    C
;

define void @lift_loop(i1 %flag1, i1 %flag2) {
; CHECK-LABEL: define void @lift_loop(
; CHECK-SAME: i1 [[FLAG1:%.*]], i1 [[FLAG2:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    br label %[[A1:.*]]
; CHECK:       [[A1]]:
; CHECK-NEXT:    [[A:%.*]] = call token @llvm.experimental.convergence.anchor()
; CHECK-NEXT:    br i1 [[FLAG1]], label %[[A1]], label %[[B_EXT:.*]]
; CHECK:       [[B_EXT]]:
; CHECK-NEXT:    [[B1:%.*]] = call token @llvm.experimental.convergence.loop() [ "convergencectrl"(token [[A]]) ]
; CHECK-NEXT:    br label %[[B:.*]]
; CHECK:       [[B]]:
; CHECK-NEXT:    call void @convergent.op(i32 0) [ "convergencectrl"(token [[B1]]) ]
; CHECK-NEXT:    br i1 [[FLAG2]], label %[[B_EXT]], label %[[C:.*]]
; CHECK:       [[C]]:
; CHECK-NEXT:    ret void
;
entry:
  br label %A

A:
  %a1 = call token @llvm.experimental.convergence.anchor()
  br i1 %flag1, label %A, label %B

B:
  %b1 = call token @llvm.experimental.convergence.loop() [ "convergencectrl"(token %a1) ]
  call void @convergent.op(i32 0) [ "convergencectrl"(token %b1) ]
  br i1 %flag2, label %B, label %C

C:
  ret void
}

define void @false_heart_trivial() convergent {
; CHECK-LABEL: define void @false_heart_trivial(
; CHECK-SAME: ) #[[ATTR0:[0-9]+]] {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[A:%.*]] = call token @llvm.experimental.convergence.entry()
; CHECK-NEXT:    br label %[[NEXT:.*]]
; CHECK:       [[NEXT]]:
; CHECK-NEXT:    [[B:%.*]] = call token @llvm.experimental.convergence.loop() [ "convergencectrl"(token [[A]]) ]
; CHECK-NEXT:    call void @convergent.op(i32 0) [ "convergencectrl"(token [[B]]) ]
; CHECK-NEXT:    ret void
;
entry:
  %a1 = call token @llvm.experimental.convergence.entry()
  br label %next

next:
  %b1 = call token @llvm.experimental.convergence.loop() [ "convergencectrl"(token %a1) ]
  call void @convergent.op(i32 0) [ "convergencectrl"(token %b1) ]
  ret void
}

;
;    |
;    A]     %a1 = loop heart
;    |
;    B      %b1 = false heart (%a1)
;           %b2 = user (%b1)
;

define void @false_heart_lifted(i1 %flag1) {
; CHECK-LABEL: define void @false_heart_lifted(
; CHECK-SAME: i1 [[FLAG1:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[ANCHOR:%.*]] = call token @llvm.experimental.convergence.anchor()
; CHECK-NEXT:    br label %[[A1:.*]]
; CHECK:       [[A1]]:
; CHECK-NEXT:    [[A:%.*]] = call token @llvm.experimental.convergence.loop() [ "convergencectrl"(token [[ANCHOR]]) ]
; CHECK-NEXT:    br i1 [[FLAG1]], label %[[EXTEND_GUARD:.*]], label %[[B_EXT:.*]]
; CHECK:       [[B_EXT]]:
; CHECK-NEXT:    [[B1:%.*]] = call token @llvm.experimental.convergence.loop() [ "convergencectrl"(token [[A]]) ]
; CHECK-NEXT:    br label %[[B_EXT1:.*]]
; CHECK:       [[B_EXT1]]:
; CHECK-NEXT:    call void @convergent.op(i32 0) [ "convergencectrl"(token [[B1]]) ]
; CHECK-NEXT:    br label %[[EXTEND_GUARD]]
; CHECK:       [[B:.*]]:
; CHECK-NEXT:    ret void
; CHECK:       [[EXTEND_GUARD]]:
; CHECK-NEXT:    [[GUARD_B:%.*]] = phi i1 [ true, %[[B_EXT1]] ], [ false, %[[A1]] ]
; CHECK-NEXT:    br i1 [[GUARD_B]], label %[[B]], label %[[A1]]
;
entry:
  %anchor = call token @llvm.experimental.convergence.anchor()
  br label %A

A:
  %a1 = call token @llvm.experimental.convergence.loop() [ "convergencectrl"(token %anchor) ]
  br i1 %flag1, label %A, label %B

B:
  %b1 = call token @llvm.experimental.convergence.loop() [ "convergencectrl"(token %a1) ]
  call void @convergent.op(i32 0) [ "convergencectrl"(token %b1) ]
  ret void
}

declare void @convergent.op(i32) convergent

declare token @llvm.experimental.convergence.entry()
declare token @llvm.experimental.convergence.anchor()
declare token @llvm.experimental.convergence.loop()
