; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt < %s -passes=indvars -S | FileCheck %s

target datalayout = "n8:16:32:64"

; This test is inspired by a miscompilation of llvm by itself in
; ``ValueTracking.cpp matchSimpleReccurence``.
; Because of that, the assignment ``Start = R;`` was not emitted
; although ``true`` was returned.

define dso_local noundef zeroext i1 @matchSimpleRecurrence(
; CHECK-LABEL: define dso_local noundef zeroext i1 @matchSimpleRecurrence(
; CHECK-SAME: ptr nocapture noundef readonly [[P:%.*]], ptr nocapture noundef nonnull writeonly align 8 dereferenceable(8) [[START:%.*]], ptr nocapture noundef nonnull writeonly align 8 dereferenceable(8) [[STEP:%.*]]) local_unnamed_addr {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    br label %[[FOR_BODY:.*]]
; CHECK:       [[FOR_BODY]]:
; CHECK-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ [[INDVARS_IV_NEXT:%.*]], %[[FOR_INC:.*]] ], [ 0, %[[ENTRY]] ]
; CHECK-NEXT:    [[CMP_NOT17:%.*]] = phi i1 [ true, %[[ENTRY]] ], [ [[CMP_NOT:%.*]], %[[FOR_INC]] ]
; CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds ptr, ptr [[P]], i64 [[INDVARS_IV]]
; CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[ARRAYIDX]], align 8
; CHECK-NEXT:    [[TOBOOL3_NOT:%.*]] = icmp eq ptr [[TMP0]], null
; CHECK-NEXT:    br i1 [[TOBOOL3_NOT]], label %[[FOR_INC]], label %[[IF_THEN:.*]]
; CHECK:       [[IF_THEN]]:
; CHECK-NEXT:    [[CMP_NOT17_LCSSA:%.*]] = phi i1 [ [[CMP_NOT17]], %[[FOR_BODY]] ]
; CHECK-NEXT:    [[I_016_LCSSA_WIDE:%.*]] = phi i64 [ [[INDVARS_IV]], %[[FOR_BODY]] ]
; CHECK-NEXT:    [[DOTLCSSA:%.*]] = phi ptr [ [[TMP0]], %[[FOR_BODY]] ]
; CHECK-NEXT:    [[TMP1:%.*]] = icmp eq i64 [[I_016_LCSSA_WIDE]], 0
; CHECK-NEXT:    [[IDXPROM1:%.*]] = zext i1 [[TMP1]] to i64
; CHECK-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds ptr, ptr [[P]], i64 [[IDXPROM1]]
; CHECK-NEXT:    [[TMP2:%.*]] = load ptr, ptr [[ARRAYIDX2]], align 8
; CHECK-NEXT:    store ptr [[TMP2]], ptr [[START]], align 8
; CHECK-NEXT:    store ptr [[DOTLCSSA]], ptr [[STEP]], align 8
; CHECK-NEXT:    br label %[[CLEANUP5:.*]]
; CHECK:       [[FOR_INC]]:
; CHECK-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1
; CHECK-NEXT:    [[CMP_NOT]] = icmp ne i64 [[INDVARS_IV_NEXT]], 2
; CHECK-NEXT:    br i1 [[CMP_NOT]], label %[[FOR_BODY]], label %[[CLEANUP5_LOOPEXIT:.*]]
; CHECK:       [[CLEANUP5_LOOPEXIT]]:
; CHECK-NEXT:    [[CMP_NOT_LCSSA:%.*]] = phi i1 [ [[CMP_NOT]], %[[FOR_INC]] ]
; CHECK-NEXT:    br label %[[CLEANUP5]]
; CHECK:       [[CLEANUP5]]:
; CHECK-NEXT:    [[CMP_NOT14:%.*]] = phi i1 [ [[CMP_NOT17_LCSSA]], %[[IF_THEN]] ], [ [[CMP_NOT_LCSSA]], %[[CLEANUP5_LOOPEXIT]] ]
; CHECK-NEXT:    ret i1 [[CMP_NOT14]]
;
  ptr nocapture noundef readonly %P,
  ptr nocapture noundef nonnull writeonly align 8 dereferenceable(8) %Start,
  ptr nocapture noundef nonnull writeonly align 8 dereferenceable(8) %Step
) local_unnamed_addr {
entry:
  br label %for.body

for.body:                                         ; preds = %entry, %for.inc
  %cmp.not17 = phi i1 [ true, %entry ], [ %cmp.not, %for.inc ]
  %i.016 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
  %idxprom = zext nneg i32 %i.016 to i64
  %arrayidx = getelementptr inbounds ptr, ptr %P, i64 %idxprom
  %0 = load ptr, ptr %arrayidx, align 8
  %tobool3.not = icmp eq ptr %0, null
  br i1 %tobool3.not, label %for.inc, label %if.then

if.then:                                          ; preds = %for.body
  %tobool.not = icmp eq i32 %i.016, 0
  %idxprom1 = zext i1 %tobool.not to i64
  %arrayidx2 = getelementptr inbounds ptr, ptr %P, i64 %idxprom1
  %1 = load ptr, ptr %arrayidx2, align 8
  store ptr %1, ptr %Start, align 8
  store ptr %0, ptr %Step, align 8
  br label %cleanup5

for.inc:                                          ; preds = %for.body
  %inc = add nuw nsw i32 %i.016, 1
  %cmp.not = icmp ne i32 %inc, 2
  br i1 %cmp.not, label %for.body, label %cleanup5.loopexit

cleanup5.loopexit:                                ; preds = %for.inc
  br label %cleanup5

cleanup5:                                         ; preds = %cleanup5.loopexit, %if.then
  %cmp.not14 = phi i1 [ %cmp.not17, %if.then ], [ %cmp.not, %cleanup5.loopexit ]
  ret i1 %cmp.not14
}


define i1 @check_size_str(ptr %str, i32 %str.size, i32 %n) {
; CHECK-LABEL: define i1 @check_size_str(
; CHECK-SAME: ptr [[STR:%.*]], i32 [[STR_SIZE:%.*]], i32 [[N:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    br label %[[LOOP:.*]]
; CHECK:       [[LOOP]]:
; CHECK-NEXT:    [[I:%.*]] = phi i64 [ 0, %[[ENTRY]] ], [ [[I_INC:%.*]], %[[LOOP]] ]
; CHECK-NEXT:    [[I_INC]] = add nuw nsw i64 [[I]], 1
; CHECK-NEXT:    [[STR_I:%.*]] = getelementptr i8, ptr [[STR]], i64 [[I]]
; CHECK-NEXT:    [[CHAR:%.*]] = load i8, ptr [[STR_I]], align 1
; CHECK-NEXT:    [[CMP_CHAR:%.*]] = icmp eq i8 [[CHAR]], 0
; CHECK-NEXT:    [[STR_SIZE_64:%.*]] = zext i32 [[STR_SIZE]] to i64
; CHECK-NEXT:    [[CMP_I:%.*]] = icmp eq i64 [[I]], [[STR_SIZE_64]]
; CHECK-NEXT:    [[OR:%.*]] = or i1 [[CMP_I]], [[CMP_CHAR]]
; CHECK-NEXT:    br i1 [[OR]], label %[[EXIT:.*]], label %[[LOOP]]
; CHECK:       [[EXIT]]:
; CHECK-NEXT:    [[I_LCSSA:%.*]] = phi i64 [ [[I]], %[[LOOP]] ]
; CHECK-NEXT:    [[ZEXT:%.*]] = zext i32 [[N]] to i64
; CHECK-NEXT:    [[TMP0:%.*]] = icmp eq i64 [[I_LCSSA]], [[ZEXT]]
; CHECK-NEXT:    ret i1 [[TMP0]]
;
entry:
  br label %loop

loop:
  %i = phi i64 [0, %entry], [%i.inc, %loop]
  %i.inc = add nuw nsw i64 %i, 1

  %str.i = getelementptr i8, ptr %str, i64 %i
  %char = load i8, ptr %str.i, align 1
  %cmp.char = icmp eq i8 %char, 0

  %str.size.64 = zext i32 %str.size to i64
  %cmp.i = icmp eq i64 %i, %str.size.64

  %or = or i1 %cmp.i, %cmp.char
  br i1 %or, label %exit, label %loop

exit:
  %i.32 = trunc nuw nsw i64 %i to i32
  %cmp.i.32 = icmp eq i32 %i.32, %n
  ret i1 %cmp.i.32
}
