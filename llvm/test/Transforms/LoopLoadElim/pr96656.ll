; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt -passes=loop-load-elim -S %s | FileCheck %s

define void @single_iteration_versioning(ptr %arg, ptr %arg1, i1 %arg2) {
; CHECK-LABEL: define void @single_iteration_versioning(
; CHECK-SAME: ptr [[ARG:%.*]], ptr [[ARG1:%.*]], i1 [[ARG2:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[LOAD:%.*]] = load i32, ptr [[ARG]], align 4
; CHECK-NEXT:    br i1 [[ARG2]], label %[[NOLOOP_EXIT:.*]], label %[[LOOP_PH:.*]]
; CHECK:       [[LOOP_PH]]:
; CHECK-NEXT:    [[SEXT7:%.*]] = sext i32 [[LOAD]] to i64
; CHECK-NEXT:    [[GEP8:%.*]] = getelementptr i8, ptr [[ARG1]], i64 8
; CHECK-NEXT:    [[GEP9:%.*]] = getelementptr i8, ptr [[ARG1]], i64 16
; CHECK-NEXT:    [[LOAD_INITIAL:%.*]] = load double, ptr [[GEP8]], align 8
; CHECK-NEXT:    br label %[[LOOP:.*]]
; CHECK:       [[LOOP]]:
; CHECK-NEXT:    [[STORE_FORWARDED:%.*]] = phi double [ [[LOAD_INITIAL]], %[[LOOP_PH]] ], [ [[STORE_FORWARDED]], %[[LOOP]] ]
; CHECK-NEXT:    [[PHI1:%.*]] = phi i64 [ 0, %[[LOOP_PH]] ], [ [[ADD1:%.*]], %[[LOOP]] ]
; CHECK-NEXT:    [[MUL1:%.*]] = mul i64 [[PHI1]], [[SEXT7]]
; CHECK-NEXT:    [[GEP11:%.*]] = getelementptr double, ptr [[GEP8]], i64 [[MUL1]]
; CHECK-NEXT:    [[LOAD12:%.*]] = load double, ptr [[GEP11]], align 8
; CHECK-NEXT:    [[GEP13:%.*]] = getelementptr double, ptr [[GEP9]], i64 [[MUL1]]
; CHECK-NEXT:    store double [[STORE_FORWARDED]], ptr [[GEP13]], align 8
; CHECK-NEXT:    [[ADD1]] = add i64 [[PHI1]], 1
; CHECK-NEXT:    [[ICMP:%.*]] = icmp eq i64 [[PHI1]], 1
; CHECK-NEXT:    br i1 [[ICMP]], label %[[EXIT_LOOPEXIT:.*]], label %[[LOOP]]
; CHECK:       [[NOLOOP_EXIT]]:
; CHECK-NEXT:    [[SEXT2:%.*]] = sext i32 [[LOAD]] to i64
; CHECK-NEXT:    [[GEP2:%.*]] = getelementptr double, ptr [[ARG1]], i64 [[SEXT2]]
; CHECK-NEXT:    [[LOAD6:%.*]] = load double, ptr [[GEP2]], align 8
; CHECK-NEXT:    store double [[LOAD6]], ptr [[ARG]], align 8
; CHECK-NEXT:    br label %[[EXIT:.*]]
; CHECK:       [[EXIT_LOOPEXIT]]:
; CHECK-NEXT:    br label %[[EXIT]]
; CHECK:       [[EXIT]]:
; CHECK-NEXT:    ret void
;
entry:
  %load = load i32, ptr %arg, align 4
  br i1 %arg2, label %noloop.exit, label %loop.ph

loop.ph:                                              ; preds = %entry
  %sext7 = sext i32 %load to i64
  %gep8 = getelementptr i8, ptr %arg1, i64 8
  %gep9 = getelementptr i8, ptr %arg1, i64 16
  br label %loop

loop:                                                 ; preds = %loop, %loop.ph
  %phi = phi i64 [ 0, %loop.ph ], [ %add, %loop ]
  %mul = mul i64 %phi, %sext7
  %gep11 = getelementptr double, ptr %gep8, i64 %mul
  %load12 = load double, ptr %gep11, align 8
  %gep13 = getelementptr double, ptr %gep9, i64 %mul
  store double %load12, ptr %gep13, align 8
  %add = add i64 %phi, 1
  %icmp = icmp eq i64 %phi, 1
  br i1 %icmp, label %exit, label %loop

noloop.exit:                                          ; preds = %loop.ph
  %sext = sext i32 %load to i64
  %gep = getelementptr double, ptr %arg1, i64 %sext
  %load5 = load double, ptr %gep, align 8
  store double %load5, ptr %arg, align 8
  br label %exit

exit:                                                 ; preds = %loop.body
  ret void
}
