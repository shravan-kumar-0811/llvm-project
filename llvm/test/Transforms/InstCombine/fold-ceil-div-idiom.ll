; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 4
; RUN: opt < %s -passes=instcombine -S | FileCheck %s

define i8 @ceil_div_idiom(i8 %x, i8 %y) {
; CHECK-LABEL: define i8 @ceil_div_idiom(
; CHECK-SAME: i8 [[X:%.*]], i8 [[Y:%.*]]) {
; CHECK-NEXT:    [[WO:%.*]] = call { i8, i1 } @llvm.uadd.with.overflow.i8(i8 [[X]], i8 [[Y]])
; CHECK-NEXT:    [[OV:%.*]] = extractvalue { i8, i1 } [[WO]], 1
; CHECK-NEXT:    [[OV_NOT:%.*]] = xor i1 [[OV]], true
; CHECK-NEXT:    call void @llvm.assume(i1 [[OV_NOT]])
; CHECK-NEXT:    [[NONZERO:%.*]] = icmp ne i8 [[X]], 0
; CHECK-NEXT:    [[BIAS:%.*]] = zext i1 [[NONZERO]] to i8
; CHECK-NEXT:    [[SUB:%.*]] = sub i8 [[X]], [[BIAS]]
; CHECK-NEXT:    [[DIV:%.*]] = udiv i8 [[SUB]], [[Y]]
; CHECK-NEXT:    [[ADD:%.*]] = add i8 [[DIV]], [[BIAS]]
; CHECK-NEXT:    ret i8 [[ADD]]
;
  %wo = call {i8, i1} @llvm.uadd.with.overflow(i8 %x, i8 %y)
  %ov = extractvalue {i8, i1} %wo, 1
  %ov.not = xor i1 %ov, true
  call void @llvm.assume(i1 %ov.not)

  %nonzero = icmp ne i8 %x, 0
  %bias = zext i1 %nonzero to i8
  %sub = sub i8 %x, %bias
  %div = udiv i8 %sub, %y
  %add = add i8 %div, %bias
  ret i8 %add
}

define i8 @ceil_div_idiom_2(i8 %x, i8 %y) {
; CHECK-LABEL: define i8 @ceil_div_idiom_2(
; CHECK-SAME: i8 [[X:%.*]], i8 [[Y:%.*]]) {
; CHECK-NEXT:    [[OV_NOT:%.*]] = add nuw i8 [[X]], [[Y]]
; CHECK-NEXT:    [[TRUNC:%.*]] = trunc i8 [[OV_NOT]] to i1
; CHECK-NEXT:    call void @llvm.assume(i1 [[TRUNC]])
; CHECK-NEXT:    [[NONZERO:%.*]] = icmp ne i8 [[X]], 0
; CHECK-NEXT:    [[BIAS:%.*]] = zext i1 [[NONZERO]] to i8
; CHECK-NEXT:    [[SUB:%.*]] = sub i8 [[X]], [[BIAS]]
; CHECK-NEXT:    [[DIV:%.*]] = udiv i8 [[SUB]], [[Y]]
; CHECK-NEXT:    [[ADD:%.*]] = add i8 [[DIV]], [[BIAS]]
; CHECK-NEXT:    ret i8 [[ADD]]
;
  %ov.not = add nuw i8 %x, %y
  %trunc = trunc i8 %ov.not to i1
  call void @llvm.assume(i1 %trunc)

  %nonzero = icmp ne i8 %x, 0
  %bias = zext i1 %nonzero to i8
  %sub = sub i8 %x, %bias
  %div = udiv i8 %sub, %y
  %add = add i8 %div, %bias
  ret i8 %add
}

define i8 @ceil_div_idiom_with_lshr(i8 %x, i8 %y) {
; CHECK-LABEL: define i8 @ceil_div_idiom_with_lshr(
; CHECK-SAME: i8 [[X:%.*]], i8 [[Y:%.*]]) {
; CHECK-NEXT:    [[WO:%.*]] = call { i8, i1 } @llvm.uadd.with.overflow.i8(i8 [[X]], i8 [[Y]])
; CHECK-NEXT:    [[OV:%.*]] = extractvalue { i8, i1 } [[WO]], 1
; CHECK-NEXT:    [[OV_NOT:%.*]] = xor i1 [[OV]], true
; CHECK-NEXT:    call void @llvm.assume(i1 [[OV_NOT]])
; CHECK-NEXT:    [[CTPOPULATION:%.*]] = call range(i8 0, 9) i8 @llvm.ctpop.i8(i8 [[Y]])
; CHECK-NEXT:    [[IS_POW_2:%.*]] = icmp eq i8 [[CTPOPULATION]], 1
; CHECK-NEXT:    call void @llvm.assume(i1 [[IS_POW_2]])
; CHECK-NEXT:    [[NONZERO:%.*]] = icmp ne i8 [[X]], 0
; CHECK-NEXT:    [[BIAS:%.*]] = zext i1 [[NONZERO]] to i8
; CHECK-NEXT:    [[SUB:%.*]] = sub i8 [[X]], [[BIAS]]
; CHECK-NEXT:    [[CTLZ:%.*]] = tail call range(i8 0, 9) i8 @llvm.ctlz.i8(i8 [[Y]], i1 true)
; CHECK-NEXT:    [[N:%.*]] = xor i8 [[CTLZ]], 7
; CHECK-NEXT:    [[DIV:%.*]] = lshr i8 [[SUB]], [[N]]
; CHECK-NEXT:    [[ADD:%.*]] = add i8 [[DIV]], [[BIAS]]
; CHECK-NEXT:    ret i8 [[ADD]]
;
  %wo = call {i8, i1} @llvm.uadd.with.overflow(i8 %x, i8 %y)
  %ov = extractvalue {i8, i1} %wo, 1
  %ov.not = xor i1 %ov, true
  call void @llvm.assume(i1 %ov.not)

  %ctpopulation = call i8 @llvm.ctpop.i8(i8 %y)
  %is_pow_2 = icmp eq i8 %ctpopulation, 1
  call void @llvm.assume(i1 %is_pow_2)

  %nonzero = icmp ne i8 %x, 0
  %bias = zext i1 %nonzero to i8
  %sub = sub i8 %x, %bias
  %ctlz = tail call i8 @llvm.ctlz.i8(i8 %y, i1 true)
  %n = sub i8 7, %ctlz
  %div = lshr i8 %sub, %n
  %add = add i8 %div, %bias
  ret i8 %add
}

define i8 @ceil_div_idiom_add_may_overflow(i8 %x, i8 %y) {
; CHECK-LABEL: define i8 @ceil_div_idiom_add_may_overflow(
; CHECK-SAME: i8 [[X:%.*]], i8 [[Y:%.*]]) {
; CHECK-NEXT:    [[NONZERO:%.*]] = icmp ne i8 [[X]], 0
; CHECK-NEXT:    [[BIAS:%.*]] = zext i1 [[NONZERO]] to i8
; CHECK-NEXT:    [[SUB:%.*]] = sub i8 [[X]], [[BIAS]]
; CHECK-NEXT:    [[DIV:%.*]] = udiv i8 [[SUB]], [[Y]]
; CHECK-NEXT:    [[ADD:%.*]] = add i8 [[DIV]], [[BIAS]]
; CHECK-NEXT:    ret i8 [[ADD]]
;
  %nonzero = icmp ne i8 %x, 0
  %bias = zext i1 %nonzero to i8
  %sub = sub i8 %x, %bias
  %div = udiv i8 %sub, %y
  %add = add i8 %div, %bias
  ret i8 %add
}

define i8 @ceil_div_idiom_multiuse_bias(i8 %x, i8 %y) {
; CHECK-LABEL: define i8 @ceil_div_idiom_multiuse_bias(
; CHECK-SAME: i8 [[X:%.*]], i8 [[Y:%.*]]) {
; CHECK-NEXT:    [[WO:%.*]] = call { i8, i1 } @llvm.uadd.with.overflow.i8(i8 [[X]], i8 [[Y]])
; CHECK-NEXT:    [[OV:%.*]] = extractvalue { i8, i1 } [[WO]], 1
; CHECK-NEXT:    [[OV_NOT:%.*]] = xor i1 [[OV]], true
; CHECK-NEXT:    call void @llvm.assume(i1 [[OV_NOT]])
; CHECK-NEXT:    [[NONZERO:%.*]] = icmp ne i8 [[X]], 0
; CHECK-NEXT:    [[BIAS:%.*]] = zext i1 [[NONZERO]] to i8
; CHECK-NEXT:    [[SUB:%.*]] = sub i8 [[X]], [[BIAS]]
; CHECK-NEXT:    [[DIV:%.*]] = udiv i8 [[SUB]], [[Y]]
; CHECK-NEXT:    [[ADD:%.*]] = add i8 [[DIV]], [[BIAS]]
; CHECK-NEXT:    call void @use(i8 [[BIAS]])
; CHECK-NEXT:    ret i8 [[ADD]]
;
  %wo = call {i8, i1} @llvm.uadd.with.overflow(i8 %x, i8 %y)
  %ov = extractvalue {i8, i1} %wo, 1
  %ov.not = xor i1 %ov, true
  call void @llvm.assume(i1 %ov.not)

  %nonzero = icmp ne i8 %x, 0
  %bias = zext i1 %nonzero to i8
  %sub = sub i8 %x, %bias
  %div = udiv i8 %sub, %y
  %add = add i8 %div, %bias
  call void @use(i8 %bias)
  ret i8 %add
}

define i8 @ceil_div_idiom_with_lshr_not_power_2(i8 %x, i8 %y) {
; CHECK-LABEL: define i8 @ceil_div_idiom_with_lshr_not_power_2(
; CHECK-SAME: i8 [[X:%.*]], i8 [[Y:%.*]]) {
; CHECK-NEXT:    [[WO:%.*]] = call { i8, i1 } @llvm.uadd.with.overflow.i8(i8 [[X]], i8 [[Y]])
; CHECK-NEXT:    [[OV:%.*]] = extractvalue { i8, i1 } [[WO]], 1
; CHECK-NEXT:    [[OV_NOT:%.*]] = xor i1 [[OV]], true
; CHECK-NEXT:    call void @llvm.assume(i1 [[OV_NOT]])
; CHECK-NEXT:    [[NONZERO:%.*]] = icmp ne i8 [[X]], 0
; CHECK-NEXT:    [[BIAS:%.*]] = zext i1 [[NONZERO]] to i8
; CHECK-NEXT:    [[SUB:%.*]] = sub i8 [[X]], [[BIAS]]
; CHECK-NEXT:    [[CTLZ:%.*]] = tail call range(i8 0, 9) i8 @llvm.ctlz.i8(i8 [[Y]], i1 true)
; CHECK-NEXT:    [[N:%.*]] = xor i8 [[CTLZ]], 7
; CHECK-NEXT:    [[DIV:%.*]] = lshr i8 [[SUB]], [[N]]
; CHECK-NEXT:    [[ADD:%.*]] = add i8 [[DIV]], [[BIAS]]
; CHECK-NEXT:    ret i8 [[ADD]]
;
  %wo = call {i8, i1} @llvm.uadd.with.overflow(i8 %x, i8 %y)
  %ov = extractvalue {i8, i1} %wo, 1
  %ov.not = xor i1 %ov, true
  call void @llvm.assume(i1 %ov.not)

  %nonzero = icmp ne i8 %x, 0
  %bias = zext i1 %nonzero to i8
  %sub = sub i8 %x, %bias
  %ctlz = tail call i8 @llvm.ctlz.i8(i8 %y, i1 true)
  %n = sub i8 7, %ctlz
  %div = lshr i8 %sub, %n
  %add = add i8 %div, %bias
  ret i8 %add
}

define i8 @ceil_div_idiom_with_lshr_wrong_bw(i8 %x, i8 %y) {
; CHECK-LABEL: define i8 @ceil_div_idiom_with_lshr_wrong_bw(
; CHECK-SAME: i8 [[X:%.*]], i8 [[Y:%.*]]) {
; CHECK-NEXT:    [[WO:%.*]] = call { i8, i1 } @llvm.uadd.with.overflow.i8(i8 [[X]], i8 [[Y]])
; CHECK-NEXT:    [[OV:%.*]] = extractvalue { i8, i1 } [[WO]], 1
; CHECK-NEXT:    [[OV_NOT:%.*]] = xor i1 [[OV]], true
; CHECK-NEXT:    call void @llvm.assume(i1 [[OV_NOT]])
; CHECK-NEXT:    [[CTPOPULATION:%.*]] = call range(i8 0, 9) i8 @llvm.ctpop.i8(i8 [[Y]])
; CHECK-NEXT:    [[IS_POW_2:%.*]] = icmp eq i8 [[CTPOPULATION]], 1
; CHECK-NEXT:    call void @llvm.assume(i1 [[IS_POW_2]])
; CHECK-NEXT:    [[NONZERO:%.*]] = icmp ne i8 [[X]], 0
; CHECK-NEXT:    [[BIAS:%.*]] = zext i1 [[NONZERO]] to i8
; CHECK-NEXT:    [[SUB:%.*]] = sub i8 [[X]], [[BIAS]]
; CHECK-NEXT:    [[CTLZ:%.*]] = tail call range(i8 0, 9) i8 @llvm.ctlz.i8(i8 [[Y]], i1 true)
; CHECK-NEXT:    [[N:%.*]] = sub nuw nsw i8 8, [[CTLZ]]
; CHECK-NEXT:    [[DIV:%.*]] = lshr i8 [[SUB]], [[N]]
; CHECK-NEXT:    [[ADD:%.*]] = add i8 [[DIV]], [[BIAS]]
; CHECK-NEXT:    ret i8 [[ADD]]
;
  %wo = call {i8, i1} @llvm.uadd.with.overflow(i8 %x, i8 %y)
  %ov = extractvalue {i8, i1} %wo, 1
  %ov.not = xor i1 %ov, true
  call void @llvm.assume(i1 %ov.not)

  %ctpopulation = call i8 @llvm.ctpop.i8(i8 %y)
  %is_pow_2 = icmp eq i8 %ctpopulation, 1
  call void @llvm.assume(i1 %is_pow_2)

  %nonzero = icmp ne i8 %x, 0
  %bias = zext i1 %nonzero to i8
  %sub = sub i8 %x, %bias
  %ctlz = tail call i8 @llvm.ctlz.i8(i8 %y, i1 true)
  %n = sub i8 8, %ctlz
  %div = lshr i8 %sub, %n
  %add = add i8 %div, %bias
  ret i8 %add
}

declare { i8, i1 } @llvm.uadd.with.overflow.i8(i8, i8)
declare i8 @llvm.ctpop.i8(i8)
declare void @llvm.assume(i1)
declare void @use(i8)
