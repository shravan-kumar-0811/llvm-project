; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt -passes=licm -S < %s | FileCheck %s

target datalayout = "e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128-ni:1"

declare void @use_i64(i64 %0)
declare void @use_p1(ptr addrspace(1) %0)
declare i1 @cond()

define void @dont_hoist_ptrtoint(ptr addrspace(1) %p) {
; CHECK-LABEL: define void @dont_hoist_ptrtoint(
; CHECK-SAME: ptr addrspace(1) [[P:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    br label %[[LOOP:.*]]
; CHECK:       [[LOOP]]:
; CHECK-NEXT:    [[P_INT:%.*]] = ptrtoint ptr addrspace(1) [[P]] to i64
; CHECK-NEXT:    call void @use_i64(i64 [[P_INT]])
; CHECK-NEXT:    br label %[[LOOP]]
;
entry:
  br label %loop

loop:
  %p.int = ptrtoint ptr addrspace(1) %p to i64
  call void @use_i64(i64 %p.int)
  br label %loop
}

define void @dont_hoist_inttoptr(i64 %p.int) {
; CHECK-LABEL: define void @dont_hoist_inttoptr(
; CHECK-SAME: i64 [[P_INT:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    br label %[[LOOP:.*]]
; CHECK:       [[LOOP]]:
; CHECK-NEXT:    [[P:%.*]] = inttoptr i64 [[P_INT]] to ptr addrspace(1)
; CHECK-NEXT:    call void @use_p1(ptr addrspace(1) [[P]])
; CHECK-NEXT:    br label %[[LOOP]]
;
entry:
  br label %loop

loop:
  %p = inttoptr i64 %p.int to ptr addrspace(1)
  call void @use_p1(ptr addrspace(1) %p)
  br label %loop
}

define i64 @dont_sink_ptrtoint(ptr addrspace(1) %p) {
; CHECK-LABEL: define i64 @dont_sink_ptrtoint(
; CHECK-SAME: ptr addrspace(1) [[P:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    br label %[[LOOP:.*]]
; CHECK:       [[LOOP]]:
; CHECK-NEXT:    [[P_INT_LE:%.*]] = ptrtoint ptr addrspace(1) [[P]] to i64
; CHECK-NEXT:    [[C:%.*]] = call i1 @cond()
; CHECK-NEXT:    br i1 [[C]], label %[[LOOP]], label %[[EXIT:.*]]
; CHECK:       [[EXIT]]:
; CHECK-NEXT:    [[P_INT_LCSSA:%.*]] = phi i64 [ [[P_INT_LE]], %[[LOOP]] ]
; CHECK-NEXT:    ret i64 [[P_INT_LCSSA]]
;
entry:
  br label %loop

loop:
  %p.int = ptrtoint ptr addrspace(1) %p to i64
  %c = call i1 @cond()
  br i1 %c, label %loop, label %exit

exit:
  ret i64 %p.int
}

define ptr addrspace(1) @dont_sink_inttoptr(i64 %p.int) {
; CHECK-LABEL: define ptr addrspace(1) @dont_sink_inttoptr(
; CHECK-SAME: i64 [[P_INT:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    br label %[[LOOP:.*]]
; CHECK:       [[LOOP]]:
; CHECK-NEXT:    [[P_LE:%.*]] = inttoptr i64 [[P_INT]] to ptr addrspace(1)
; CHECK-NEXT:    [[C:%.*]] = call i1 @cond()
; CHECK-NEXT:    br i1 [[C]], label %[[LOOP]], label %[[EXIT:.*]]
; CHECK:       [[EXIT]]:
; CHECK-NEXT:    [[P_LCSSA:%.*]] = phi ptr addrspace(1) [ [[P_LE]], %[[LOOP]] ]
; CHECK-NEXT:    ret ptr addrspace(1) [[P_LCSSA]]
;
entry:
  br label %loop

loop:
  %p = inttoptr i64 %p.int to ptr addrspace(1)
  %c = call i1 @cond()
  br i1 %c, label %loop, label %exit

exit:
  ret ptr addrspace(1) %p
}
