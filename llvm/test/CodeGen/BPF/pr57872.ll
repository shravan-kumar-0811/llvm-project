; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc < %s -mtriple=bpf-- | FileCheck %s

%struct.event = type { i8, [84 x i8] }

define void @foo(ptr %g) {
; CHECK-LABEL: foo:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    r2 = 0
; CHECK-NEXT:    r1 = *(u64 *)(r1 + 0)
; CHECK-NEXT:    r3 = 84
; CHECK-NEXT:  LBB0_1: # %load-store-loop
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    r4 = r10
; CHECK-NEXT:    r4 += -88
; CHECK-NEXT:    r4 += r2
; CHECK-NEXT:    r5 = r1
; CHECK-NEXT:    r5 += r2
; CHECK-NEXT:    r5 = *(u8 *)(r5 + 0)
; CHECK-NEXT:    *(u8 *)(r4 + 1) = r5
; CHECK-NEXT:    r2 += 1
; CHECK-NEXT:    if r3 > r2 goto LBB0_1
; CHECK-NEXT:  # %bb.2: # %memcpy-split
; CHECK-NEXT:    r1 = r10
; CHECK-NEXT:    r1 += -88
; CHECK-NEXT:    call bar
; CHECK-NEXT:    exit
entry:
  %event = alloca %struct.event, align 8
  %hostname = getelementptr inbounds %struct.event, ptr %event, i64 0, i32 1
  %0 = load ptr, ptr %g, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(84) %hostname, ptr noundef nonnull align 1 dereferenceable(84) %0, i64 84, i1 false)
  call void @bar(ptr noundef nonnull %event)
  ret void
}

declare void @llvm.memcpy.p0.p0.i64(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i64, i1 immarg) #2
declare void @bar(ptr noundef)
