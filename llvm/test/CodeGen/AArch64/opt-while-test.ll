; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 5
; RUN: llc                < %s | FileCheck %s
; RUN: llc -mattr=+sve2p1 < %s | FileCheck %s --check-prefix=CHECK-SVE2p1
target triple = "aarch64-linux"

define void @f_while(i32 %i, i32 %n) #0 {
; CHECK-LABEL: f_while:
; CHECK:       // %bb.0: // %E
; CHECK-NEXT:    str x30, [sp, #-16]! // 8-byte Folded Spill
; CHECK-NEXT:    whilelo p0.b, w0, w1
; CHECK-NEXT:    b.pl .LBB0_2
; CHECK-NEXT:  // %bb.1: // %A
; CHECK-NEXT:    bl g0
; CHECK-NEXT:    ldr x30, [sp], #16 // 8-byte Folded Reload
; CHECK-NEXT:    ret
; CHECK-NEXT:  .LBB0_2: // %B
; CHECK-NEXT:    bl g1
; CHECK-NEXT:    ldr x30, [sp], #16 // 8-byte Folded Reload
; CHECK-NEXT:    ret
;
; CHECK-SVE2p1-LABEL: f_while:
; CHECK-SVE2p1:       // %bb.0: // %E
; CHECK-SVE2p1-NEXT:    str x30, [sp, #-16]! // 8-byte Folded Spill
; CHECK-SVE2p1-NEXT:    whilelo p0.b, w0, w1
; CHECK-SVE2p1-NEXT:    b.pl .LBB0_2
; CHECK-SVE2p1-NEXT:  // %bb.1: // %A
; CHECK-SVE2p1-NEXT:    bl g0
; CHECK-SVE2p1-NEXT:    ldr x30, [sp], #16 // 8-byte Folded Reload
; CHECK-SVE2p1-NEXT:    ret
; CHECK-SVE2p1-NEXT:  .LBB0_2: // %B
; CHECK-SVE2p1-NEXT:    bl g1
; CHECK-SVE2p1-NEXT:    ldr x30, [sp], #16 // 8-byte Folded Reload
; CHECK-SVE2p1-NEXT:    ret
E:
  %wide.mask = call <vscale x 16 x i1> @llvm.get.active.lane.mask.nxv16i1.i64(i32 %i, i32 %n)
  %mask = call <vscale x 8 x i1> @llvm.vector.extract.nxv8i1.nxv16i1(<vscale x 16 x i1> %wide.mask, i64 0)
  %elt = extractelement <vscale x 8 x i1> %mask, i64 0
  br i1 %elt, label %A, label %B
A:
  call void @g0()
  ret void
B:
  call void @g1()
  ret void
}

define void @f_while_x2(i32 %i, i32 %n) #0 {
; CHECK-LABEL: f_while_x2:
; CHECK:       // %bb.0: // %E
; CHECK-NEXT:    str x30, [sp, #-16]! // 8-byte Folded Spill
; CHECK-NEXT:    whilelo p0.b, w0, w1
; CHECK-NEXT:    punpkhi p0.h, p0.b
; CHECK-NEXT:    b.pl .LBB1_2
; CHECK-NEXT:  // %bb.1: // %A
; CHECK-NEXT:    bl g0
; CHECK-NEXT:    ldr x30, [sp], #16 // 8-byte Folded Reload
; CHECK-NEXT:    ret
; CHECK-NEXT:  .LBB1_2: // %B
; CHECK-NEXT:    bl g1
; CHECK-NEXT:    ldr x30, [sp], #16 // 8-byte Folded Reload
; CHECK-NEXT:    ret
;
; CHECK-SVE2p1-LABEL: f_while_x2:
; CHECK-SVE2p1:       // %bb.0: // %E
; CHECK-SVE2p1-NEXT:    str x30, [sp, #-16]! // 8-byte Folded Spill
; CHECK-SVE2p1-NEXT:    mov w8, w1
; CHECK-SVE2p1-NEXT:    mov w9, w0
; CHECK-SVE2p1-NEXT:    whilelo { p0.h, p1.h }, x9, x8
; CHECK-SVE2p1-NEXT:    b.pl .LBB1_2
; CHECK-SVE2p1-NEXT:  // %bb.1: // %A
; CHECK-SVE2p1-NEXT:    mov p0.b, p1.b
; CHECK-SVE2p1-NEXT:    bl g0
; CHECK-SVE2p1-NEXT:    ldr x30, [sp], #16 // 8-byte Folded Reload
; CHECK-SVE2p1-NEXT:    ret
; CHECK-SVE2p1-NEXT:  .LBB1_2: // %B
; CHECK-SVE2p1-NEXT:    mov p0.b, p1.b
; CHECK-SVE2p1-NEXT:    bl g1
; CHECK-SVE2p1-NEXT:    ldr x30, [sp], #16 // 8-byte Folded Reload
; CHECK-SVE2p1-NEXT:    ret
E:
  %wide.mask = call <vscale x 16 x i1> @llvm.get.active.lane.mask.nxv16i1.i64(i32 %i, i32 %n)
  %mask.hi = call <vscale x 8 x i1> @llvm.vector.extract.nxv8i1.nxv16i1(<vscale x 16 x i1> %wide.mask, i64 8)
  %mask = call <vscale x 8 x i1> @llvm.vector.extract.nxv8i1.nxv16i1(<vscale x 16 x i1> %wide.mask, i64 0)
  %elt = extractelement <vscale x 8 x i1> %mask, i64 0
  br i1 %elt, label %A, label %B
A:
  call void @g0(<vscale x 8 x i1> %mask.hi)
  ret void
B:
  call void @g1(<vscale x 8 x i1> %mask.hi)
  ret void
}

declare void @g0(...)
declare void @g1(...)

attributes #0 = { nounwind vscale_range(1,16) "target-cpu"="neoverse-v1" }
