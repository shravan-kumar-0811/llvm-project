// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --version 5
// RUN: %clang_cc1 -emit-llvm -triple aarch64-arm-none-eabi -target-feature -fp8 -target-feature +neon -o - %s | FileCheck %s --check-prefixes=CHECK,CHECK-C
// RUN: %clang_cc1 -emit-llvm -triple aarch64-arm-none-eabi -target-feature -fp8 -target-feature +neon -o -  -x c++ %s | FileCheck %s --check-prefixes=CHECK,CHECK-CXX

// REQUIRES: aarch64-registered-target

// CHECK-C-LABEL: define dso_local i8 @func1n(
// CHECK-C-SAME: i8 noundef [[FPM8:%.*]]) #[[ATTR0:[0-9]+]] {
// CHECK-C-NEXT:  [[ENTRY:.*:]]
// CHECK-C-NEXT:    [[FPM8_ADDR:%.*]] = alloca i8, align 1
// CHECK-C-NEXT:    [[F1N:%.*]] = alloca [10 x i8], align 1
// CHECK-C-NEXT:    store i8 [[FPM8]], ptr [[FPM8_ADDR]], align 1
// CHECK-C-NEXT:    [[TMP0:%.*]] = load i8, ptr [[FPM8_ADDR]], align 1
// CHECK-C-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [10 x i8], ptr [[F1N]], i64 0, i64 2
// CHECK-C-NEXT:    store i8 [[TMP0]], ptr [[ARRAYIDX]], align 1
// CHECK-C-NEXT:    [[ARRAYIDX1:%.*]] = getelementptr inbounds [10 x i8], ptr [[F1N]], i64 0, i64 2
// CHECK-C-NEXT:    [[TMP1:%.*]] = load i8, ptr [[ARRAYIDX1]], align 1
// CHECK-C-NEXT:    ret i8 [[TMP1]]
//
// CHECK-CXX-LABEL: define dso_local noundef i8 @_Z6func1nw(
// CHECK-CXX-SAME: i8 noundef [[FPM8:%.*]]) #[[ATTR0:[0-9]+]] {
// CHECK-CXX-NEXT:  [[ENTRY:.*:]]
// CHECK-CXX-NEXT:    [[FPM8_ADDR:%.*]] = alloca i8, align 1
// CHECK-CXX-NEXT:    [[F1N:%.*]] = alloca [10 x i8], align 1
// CHECK-CXX-NEXT:    store i8 [[FPM8]], ptr [[FPM8_ADDR]], align 1
// CHECK-CXX-NEXT:    [[TMP0:%.*]] = load i8, ptr [[FPM8_ADDR]], align 1
// CHECK-CXX-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [10 x i8], ptr [[F1N]], i64 0, i64 2
// CHECK-CXX-NEXT:    store i8 [[TMP0]], ptr [[ARRAYIDX]], align 1
// CHECK-CXX-NEXT:    [[ARRAYIDX1:%.*]] = getelementptr inbounds [10 x i8], ptr [[F1N]], i64 0, i64 2
// CHECK-CXX-NEXT:    [[TMP1:%.*]] = load i8, ptr [[ARRAYIDX1]], align 1
// CHECK-CXX-NEXT:    ret i8 [[TMP1]]
//
__fpm8 func1n(__fpm8 fpm8) {
  __fpm8 f1n[10];
  f1n[2] = fpm8;
  return f1n[2];
}


#include <arm_neon.h>

// CHECK-C-LABEL: define dso_local <16 x i8> @test_ret_fpm8x16_t(
// CHECK-C-SAME: <16 x i8> noundef [[V:%.*]]) #[[ATTR0]] {
// CHECK-C-NEXT:  [[ENTRY:.*:]]
// CHECK-C-NEXT:    [[V_ADDR:%.*]] = alloca <16 x i8>, align 16
// CHECK-C-NEXT:    store <16 x i8> [[V]], ptr [[V_ADDR]], align 16
// CHECK-C-NEXT:    [[TMP0:%.*]] = load <16 x i8>, ptr [[V_ADDR]], align 16
// CHECK-C-NEXT:    ret <16 x i8> [[TMP0]]
//
// CHECK-CXX-LABEL: define dso_local noundef <16 x i8> @_Z18test_ret_fpm8x16_t13__Fpm8_tx16_t(
// CHECK-CXX-SAME: <16 x i8> noundef [[V:%.*]]) #[[ATTR0]] {
// CHECK-CXX-NEXT:  [[ENTRY:.*:]]
// CHECK-CXX-NEXT:    [[V_ADDR:%.*]] = alloca <16 x i8>, align 16
// CHECK-CXX-NEXT:    store <16 x i8> [[V]], ptr [[V_ADDR]], align 16
// CHECK-CXX-NEXT:    [[TMP0:%.*]] = load <16 x i8>, ptr [[V_ADDR]], align 16
// CHECK-CXX-NEXT:    ret <16 x i8> [[TMP0]]
//
fpm8x16_t test_ret_fpm8x16_t(fpm8x16_t v) {
  return v;
}

// CHECK-C-LABEL: define dso_local <8 x i8> @test_ret_fpm8x8_t(
// CHECK-C-SAME: <8 x i8> noundef [[V:%.*]]) #[[ATTR0]] {
// CHECK-C-NEXT:  [[ENTRY:.*:]]
// CHECK-C-NEXT:    [[V_ADDR:%.*]] = alloca <8 x i8>, align 8
// CHECK-C-NEXT:    store <8 x i8> [[V]], ptr [[V_ADDR]], align 8
// CHECK-C-NEXT:    [[TMP0:%.*]] = load <8 x i8>, ptr [[V_ADDR]], align 8
// CHECK-C-NEXT:    ret <8 x i8> [[TMP0]]
//
// CHECK-CXX-LABEL: define dso_local noundef <8 x i8> @_Z17test_ret_fpm8x8_t12__Fpm8_tx8_t(
// CHECK-CXX-SAME: <8 x i8> noundef [[V:%.*]]) #[[ATTR0]] {
// CHECK-CXX-NEXT:  [[ENTRY:.*:]]
// CHECK-CXX-NEXT:    [[V_ADDR:%.*]] = alloca <8 x i8>, align 8
// CHECK-CXX-NEXT:    store <8 x i8> [[V]], ptr [[V_ADDR]], align 8
// CHECK-CXX-NEXT:    [[TMP0:%.*]] = load <8 x i8>, ptr [[V_ADDR]], align 8
// CHECK-CXX-NEXT:    ret <8 x i8> [[TMP0]]
//
fpm8x8_t test_ret_fpm8x8_t(fpm8x8_t v) {
  return v;
}

//// NOTE: These prefixes are unused and the list is autogenerated. Do not add tests below this line:
// CHECK: {{.*}}
